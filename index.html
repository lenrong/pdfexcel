<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ubur Ubur Ikan Lele</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.0.2/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* CSS tetap sama */
    </style>
</head>
<body>
    <div class="container">
        <!-- HTML tetap sama -->
    </div>
    <div class="city-animation"></div>
    <script>
        let extractedData = [];
        const ROW_THRESHOLD = 10; // Pixel threshold untuk grouping baris
        const COL_THRESHOLD = 20; // Pixel threshold untuk grouping kolom

        async function processPage(page, totalYOffset) {
            const desiredWidth = 800;
            const viewport = page.getViewport({ scale: 1 });
            const scale = desiredWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale });

            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.width = scaledViewport.width;
            canvas.height = scaledViewport.height;

            await page.render({
                canvasContext: context,
                viewport: scaledViewport
            }).promise;

            const imageData = canvas.toDataURL("image/png");
            
            const { data: { words } } = await Tesseract.recognize(imageData, 'eng');
            return words.map(word => ({
                text: word.text,
                x: word.bbox.x0,
                y: word.bbox.y0 + totalYOffset
            }));
        }

        function groupIntoRows(words) {
            words.sort((a, b) => a.y - b.y);
            const rows = [];
            let currentRow = [words[0]];
            
            for (let i = 1; i < words.length; i++) {
                if (Math.abs(words[i].y - currentRow[0].y) <= ROW_THRESHOLD) {
                    currentRow.push(words[i]);
                } else {
                    rows.push(currentRow);
                    currentRow = [words[i]];
                }
            }
            rows.push(currentRow);
            return rows;
        }

        function calculateColumns(rows) {
            const allX = rows.flatMap(row => row.map(word => word.x));
            allX.sort((a, b) => a - b);
            
            const columnPositions = [];
            let currentX = allX[0];
            columnPositions.push(currentX);
            
            for (const x of allX) {
                if (x - currentX > COL_THRESHOLD) {
                    currentX = x;
                    columnPositions.push(x);
                }
            }
            return columnPositions;
        }

        function createExcelData(rows, columnPositions) {
            return rows.map(row => {
                row.sort((a, b) => a.x - b.x);
                const rowData = [];
                
                row.forEach(word => {
                    const colIndex = columnPositions.reduce((closestIdx, x, idx) => 
                        Math.abs(x - word.x) < Math.abs(columnPositions[closestIdx] - word.x) ? 
                        idx : closestIdx, 0);
                    
                    if (!rowData[colIndex]) rowData[colIndex] = '';
                    rowData[colIndex] += (rowData[colIndex] ? ' ' : '') + word.text;
                });

                return rowData;
            });
        }

        async function convertPDF() {
            const file = document.getElementById('pdfFile').files[0];
            if (!file) return alert("Pilih file PDF terlebih dahulu!");

            const reader = new FileReader();
            reader.onload = async () => {
                const pdf = await pdfjsLib.getDocument(new Uint8Array(reader.result)).promise;
                extractedData = [];
                let totalYOffset = 0;

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const words = await processPage(page, totalYOffset);
                    extractedData.push(...words);
                    const viewport = page.getViewport({ scale: 1 });
                    totalYOffset += viewport.height * (800 / viewport.width);
                }

                const rows = groupIntoRows(extractedData);
                const columnPositions = calculateColumns(rows);
                const excelData = createExcelData(rows, columnPositions);
                
                // Normalize row length
                const maxCols = Math.max(...excelData.map(row => row.length));
                extractedData = excelData.map(row => 
                    [...row, ...Array(maxCols - row.length).fill('')]
                );

                document.getElementById('status').innerText = "Konversi selesai!";
                document.getElementById('downloadExcel').style.display = "block";
            };
            reader.readAsArrayBuffer(file);
        }

        function downloadExcel() {
            const ws = XLSX.utils.aoa_to_sheet(extractedData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Data");
            XLSX.writeFile(wb, "HasilKonversi.xlsx");
        }
    </script>
</body>
</html>
